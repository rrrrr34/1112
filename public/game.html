<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ†Ø² Ø§Ù„Ù…Ø®ÙÙŠ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        
        #game-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 100;
        }
        
        .touch-control {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 200;
            text-align: center;
        }
        
        #start-button {
            padding: 15px 30px;
            font-size: 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #puzzle-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 300;
            text-align: center;
            padding: 20px;
        }
        
        .puzzle-option {
            padding: 10px 20px;
            margin: 10px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
        }
        
        #inventory {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            max-width: 200px;
        }
        
        .inventory-item {
            width: 40px;
            height: 40px;
            margin: 5px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }
        
        #mission-info {
            position: absolute;
            bottom: 120px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            z-index: 100;
            max-width: 300px;
        }
        
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            z-index: 400;
            text-align: center;
            display: none;
            max-width: 80%;
        }
        
        #close-message {
            padding: 8px 16px;
            margin-top: 15px;
            background-color: #ff5722;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    
    <div id="game-container"></div>
    
    <div id="ui">
        <div id="player-name" style="font-weight: bold; font-size: 1.2em; margin-bottom: 5px; color: #4CAF50;">MR7-MostafaAlrawi</div>
        <div id="position-info">Ø§Ù„Ù…ÙˆÙ‚Ø¹: (0, 0, 0)</div>
        <div id="score-info">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
        <div id="items-info">Ø§Ù„Ø¹Ù†Ø§ØµØ±: 0/5</div>
        <div id="clue-info">Ø§Ù„Ø¯Ù„ÙŠÙ„: Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©!</div>
        <div id="mission-text">Ø§Ø³ØªÙƒØ´Ù Ø§Ù„Ø¹Ø§Ù„Ù… ÙˆØ§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ†Ø² Ø§Ù„Ù…Ø®ÙÙŠ!</div>
        <div id="inventory"></div>
    </div>
    

    
    <div id="inventory"></div>
    
    <div id="mission-info">
        <h3>Ø§Ù„Ù…Ù‡Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:</h3>
        <p id="mission-text">Ø¬Ø¯ 5 Ù…ÙØ§ØªÙŠØ­ Ù„ÙØªØ­ Ø§Ù„Ø¨Ø§Ø¨ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ</p>
    </div>
    
    <div id="controls">
        <div class="touch-control" id="up-btn">â†‘</div>
        <div class="touch-control" id="left-btn">â†</div>
        <div class="touch-control" id="right-btn">â†’</div>
        <div class="touch-control" id="down-btn">â†“</div>
    </div>
    
    <div id="start-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; color: white; text-align: center;">
        <h1 style="font-size: 3em; margin-bottom: 10px;">Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ†Ø² Ø§Ù„Ù…Ø®ÙÙŠ</h1>
        <h2 style="font-size: 2em; margin: 0 0 10px 0; color: #4CAF50;">MR7-MostafaAlrawi</h2>
        <p style="font-size: 1.5em; margin-bottom: 30px;">Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ù…Ø®ÙÙŠØ© ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù… Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø². Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø°ÙŠ ÙŠØ¬Ø¯Ù‡ Ø£ÙˆÙ„Ø§Ù‹ ÙŠÙÙˆØ²!</p>
        <button id="start-button" style="background-color: #4CAF50; color: white; border: none; padding: 15px 30px; font-size: 1.5em; border-radius: 5px; cursor: pointer;">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…ØºØ§Ù…Ø±Ø©</button>
    </div>
    
    <div id="puzzle-screen">
        <h2 id="puzzle-title">Ù„ØºØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª</h2>
        <p id="puzzle-question">Ù…Ø§ Ù‡Ùˆ Ù†Ø§ØªØ¬ 5 + 7ØŸ</p>
        <div id="puzzle-options"></div>
    </div>
    
    <div id="message-box" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 10px; z-index: 200; min-width: 300px; text-align: center;">
        <h2 id="message-title" style="margin-top: 0;">Ø±Ø³Ø§Ù„Ø©</h2>
        <p id="message-content">Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø©!</p>
        <button id="close-message" style="background-color: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Ø¥ØºÙ„Ø§Ù‚</button>
    </div>

    <!-- Ù…ÙƒØªØ¨Ø© Three.js -->
    <!-- Socket.IO Client -->
    <script src="/socket.io/socket.io.js"></script>

    <!-- Ù…ÙƒØªØ¨Ø© Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.min.js"></script>
    <script src="treasureGame.js"></script>
    
    <script>
        // Ø¹Ù†Ø§ØµØ± DOM
        const gameContainer = document.getElementById('game-container');
        const positionInfo = document.getElementById('position-info');
        const scoreInfo = document.getElementById('score-info');
        const itemsInfo = document.getElementById('items-info');
        const startScreen = document.getElementById('start-screen');
        const puzzleScreen = document.getElementById('puzzle-screen');
        const puzzleTitle = document.getElementById('puzzle-title');
        const puzzleQuestion = document.getElementById('puzzle-question');
        const puzzleOptions = document.getElementById('puzzle-options');
        const startButton = document.getElementById('start-button');
        const missionText = document.getElementById('mission-text');
        const inventory = document.getElementById('inventory');
        const messageBox = document.getElementById('message-box');
        const messageTitle = document.getElementById('message-title');
        const messageContent = document.getElementById('message-content');
        const closeMessage = document.getElementById('close-message');
        
        // Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
        const upBtn = document.getElementById('up-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const downBtn = document.getElementById('down-btn');
        
        // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
        let scene, camera, renderer, character, floor;
        let keys = {};
        let touchControls = {
            up: false,
            left: false,
            right: false,
            down: false
        };
        let speed = 0.1;
        let rotationSpeed = 0.03;
        let score = 0;
        let collectedItems = 0;
        let gameStarted = false;
        let socket;
        let otherPlayers = {};
        let playerTargets = {};
        let interpolationFactor = 0.1; // Ø¹Ø§Ù…Ù„ Ù„Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø³Ù„Ø³
        
        // Ù…ØªØºÙŠØ±Ø§Øª Ø®Ø§ØµØ© Ø¨Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ†Ø²
        let hiddenTreasure = null; // Ø§Ù„ÙƒÙ†Ø² Ø§Ù„Ù…Ø®ÙÙŠ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        let clues = []; // Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ù…Ù†ØªØ´Ø±Ø© ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø©
        let discoveredClues = []; // Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„ØªÙŠ ØªÙ… Ø§ÙƒØªØ´Ø§ÙÙ‡Ø§
        let treasureFound = false; // Ù‡Ù„ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø²
        let winner = null; // Ø§Ù„ÙØ§Ø¦Ø² Ø§Ù„Ø°ÙŠ Ø¹Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø² Ø£ÙˆÙ„Ø§Ù‹
        
        // Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ù…ØªØ§Ø­Ø©
        const availableClues = [
            {
                title: "Ø¯Ù„ÙŠÙ„ 1",
                description: "Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø´Ø¬Ø±Ø© Ø§Ù„ÙƒØ¨ÙŠØ±Ø© ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø´Ù…Ø§Ù„ÙŠØ© Ø§Ù„Ø´Ø±Ù‚ÙŠØ©",
                position: new THREE.Vector3(20, 0, 20)
            },
            {
                title: "Ø¯Ù„ÙŠÙ„ 2",
                description: "Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØµØ®Ø±Ø© Ø§Ù„ÙƒØ¨ÙŠØ±Ø© ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ© Ø§Ù„ØºØ±Ø¨ÙŠØ©",
                position: new THREE.Vector3(-20, 0, -20)
            },
            {
                title: "Ø¯Ù„ÙŠÙ„ 3",
                description: "Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¨Ø§Ø¨ Ø§Ù„Ø®Ø´Ø¨ÙŠ ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø´Ù…Ø§Ù„ÙŠØ© Ø§Ù„ØºØ±Ø¨ÙŠØ©",
                position: new THREE.Vector3(-20, 0, 20)
            }
        ];
        
        // Ù‚Ø±Ø§Ø¡Ø© Ù…Ø¹Ù„Ù…Ø§Øª URL Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙˆÙ…Ø¹Ø±Ù Ø§Ù„ØºØ±ÙØ©
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('room') || Math.random().toString(36).substring(2, 8).toUpperCase();
        const playerName = urlParams.get('name') || 'Ù„Ø§Ø¹Ø¨' + Math.floor(Math.random() * 1000);
        
        let activePuzzle = null;
        let doors = [];
        let finalDoor = null;
        let items = [];
        
        // Ø§Ù„Ø£Ù„ØºØ§Ø² Ø§Ù„Ù…ØªØ§Ø­Ø©
        const puzzles = [
            {
                title: "Ù„ØºØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª",
                question: "Ù…Ø§ Ù‡Ùˆ Ù†Ø§ØªØ¬ 15 + 27ØŸ",
                options: ["42", "32", "52", "37"],
                correct: 0
            },
            {
                title: "Ù„ØºØ² Ø§Ù„Ù…Ù†Ø·Ù‚",
                question: "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø´ÙŠØ¡ Ø§Ù„Ø°ÙŠ ÙƒÙ„Ù…Ø§ Ø£Ø®Ø°Øª Ù…Ù†Ù‡ ÙƒØ¨Ø±ØŸ",
                options: ["Ø§Ù„Ø­ÙØ±Ø©", "Ø§Ù„ØµÙˆØ±Ø©", "Ø§Ù„ÙƒØªØ§Ø¨", "Ø§Ù„ÙƒØ¹ÙƒØ©"],
                correct: 0
            },
            {
                title: "Ù„ØºØ² Ø§Ù„Ø«Ù‚Ø§ÙØ© Ø§Ù„Ø¹Ø§Ù…Ø©",
                question: "Ù…Ø§ Ù‡ÙŠ Ø¹Ø§ØµÙ…Ø© ÙØ±Ù†Ø³Ø§ØŸ",
                options: ["Ù„Ù†Ø¯Ù†", "Ø¨Ø±Ù„ÙŠÙ†", "Ø¨Ø§Ø±ÙŠØ³", "Ø±ÙˆÙ…Ø§"],
                correct: 2
            },
            {
                title: "Ù„ØºØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª",
                question: "Ø¥Ø°Ø§ ÙƒØ§Ù† 3 Ø£Ø´Ø®Ø§Øµ ÙŠØ³ØªØºØ±Ù‚ÙˆÙ† 3 Ø³Ø§Ø¹Ø§Øª Ù„Ø¥Ù†Ù‡Ø§Ø¡ Ø¹Ù…Ù„ØŒ ÙÙƒÙ… ÙŠØ³ØªØºØ±Ù‚ 9 Ø£Ø´Ø®Ø§ØµØŸ",
                options: ["9 Ø³Ø§Ø¹Ø§Øª", "3 Ø³Ø§Ø¹Ø§Øª", "1 Ø³Ø§Ø¹Ø©", "6 Ø³Ø§Ø¹Ø§Øª"],
                correct: 1
            },
            {
                title: "Ù„ØºØ² Ø§Ù„Ù…Ù†Ø·Ù‚",
                question: "Ù…Ø§ Ø§Ù„Ø´ÙŠØ¡ Ø§Ù„Ø°ÙŠ Ù„Ù‡ Ø£ÙˆØ±Ø§Ù‚ ÙˆÙ„ÙŠØ³ Ø¨Ù†Ø¨Ø§ØªØŒ ÙˆÙ„Ù‡ Ø¬Ù„Ø¯ ÙˆÙ„ÙŠØ³ Ø¨Ø­ÙŠÙˆØ§Ù†ØŸ",
                options: ["Ø§Ù„ÙƒØªØ§Ø¨", "Ø§Ù„Ø­Ø°Ø§Ø¡", "Ø§Ù„Ø·Ø§ÙˆÙ„Ø©", "Ø§Ù„Ù‚Ù„Ù…"],
                correct: 0
            }
        ];
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø´Ù‡Ø¯
        function init() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ù‡Ø¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Ù„ÙˆÙ† Ø§Ù„Ø³Ù…Ø§Ø¡
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø³ÙˆÙ…ÙŠ
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            gameContainer.appendChild(renderer.domElement);
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 20, 10);
            scene.add(directionalLight);
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙŠØ¦Ø©
            addEnvironment();
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©
            addClues();
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒÙ†Ø² Ø§Ù„Ù…Ø®ÙÙŠ
            addHiddenTreasure();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´Ø®ØµÙŠØ©
            createCharacter();
            
            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
            setupTouchControls();
            
            // Ø¥Ø¹Ø¯Ø§Ø¯ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
            window.addEventListener('resize', onWindowResize);
            
            // Ø¥Ø¹Ø¯Ø§Ø¯ Socket.IO
            socket = io();
            
            // Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¥Ù„Ù‰ ØºØ±ÙØ©
            socket.emit('join-room', { roomId, playerName });
            
            // Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
            socket.on('state', (players) => {
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
                for (const id in players) {
                    if (id !== socket.id) {
                        const playerData = players[id];
                        
                        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ØŒ Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¦Ù‡
                        if (!otherPlayers[id]) {
                            const otherCharacter = createOtherCharacter(playerData.name);
                            otherPlayers[id] = otherCharacter;
                            scene.add(otherCharacter);
                        }
                        
                        // ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
                        if (!playerTargets[id]) {
                            playerTargets[id] = {
                                position: new THREE.Vector3(),
                                rotation: { y: 0 }
                            };
                        }
                        
                        playerTargets[id].position.set(playerData.x, playerData.y || 1, playerData.z);
                        
                        if (playerData.rotation && typeof playerData.rotation.y === 'number') {
                            playerTargets[id].rotation.y = playerData.rotation.y;
                        }
                        
                        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ÙØ§Ø¦Ø² Ø¥Ø°Ø§ ÙˆØ¬Ø¯
                        if (playerData.foundTreasure) {
                            treasureFound = true;
                            winner = playerData.name;
                            showMessage("Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©", `Ù„Ù‚Ø¯ ÙØ§Ø² ${playerData.name} Ø¨Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø²!`);
                        }
                    }
                }
            });
            
            // Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø¯Ù„Ø©
            socket.on('clue-found', ({ playerId, clueIndex }) => {
                if (playerId !== socket.id && clues[clueIndex]) {
                    const clue = clues[clueIndex];
                    clue.material.color.set(0xFFFFFF);
                    clue.material.emissive.set(0xFFFFFF);
                    showMessage("ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø¯Ù„ÙŠÙ„", `Ù„Ù‚Ø¯ ÙˆØ¬Ø¯ Ù„Ø§Ø¹Ø¨ Ø¢Ø®Ø± Ø¯Ù„ÙŠÙ„Ø§Ù‹!`);
                }
            });
            
            // Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø²
            socket.on('treasure-found', ({ playerName }) => {
                treasureFound = true;
                winner = playerName;
                if (hiddenTreasure) hiddenTreasure.visible = false;
                showMessage("Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©", `Ù„Ù‚Ø¯ ÙØ§Ø² ${playerName} Ø¨Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø²!`);
            });
            
            // Ø¨Ø¯Ø¡ Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø³Ù…
            animate();
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙŠØ¦Ø©
        function addEnvironment() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø±Ø¶ÙŠØ©
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a5f0b,
                side: THREE.DoubleSide
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Ø¥Ø¶Ø§ÙØ© Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ø´Ø¬Ø§Ø±
            const treeGeometry = new THREE.ConeGeometry(2, 5, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x2e8b57 });
            
            for (let i = 0; i < 30; i++) {
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                tree.position.x = (Math.random() - 0.5) * 80;
                tree.position.z = (Math.random() - 0.5) * 80;
                tree.position.y = 2.5;
                tree.castShadow = true;
                scene.add(tree);
                
                // Ø¬Ø°Ø¹ Ø§Ù„Ø´Ø¬Ø±Ø©
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.copy(tree.position);
                trunk.position.y = 0;
                trunk.castShadow = true;
                scene.add(trunk);
            }
            
            // Ø¥Ø¶Ø§ÙØ© Ø¨Ø¹Ø¶ Ø§Ù„ØµØ®ÙˆØ±
            const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 });
            
            for (let i = 0; i < 15; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.x = (Math.random() - 0.5) * 80;
                rock.position.z = (Math.random() - 0.5) * 80;
                rock.position.y = 0.5;
                rock.castShadow = true;
                scene.add(rock);
            }
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø¨ÙˆØ§Ø¨
        function addDoors() {
            const doorGeometry = new THREE.BoxGeometry(3, 5, 0.5);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            // Ø£Ø¨ÙˆØ§Ø¨ Ø¹Ø§Ø¯ÙŠØ©
            for (let i = 0; i < 3; i++) {
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.x = (Math.random() - 0.5) * 60;
                door.position.z = (Math.random() - 0.5) * 60;
                door.position.y = 2.5;
                door.castShadow = true;
                door.receiveShadow = true;
                door.userData.isDoor = true;
                door.userData.requiresKey = Math.random() > 0.5;
                scene.add(door);
                doors.push(door);
            }
            
            // Ø§Ù„Ø¨Ø§Ø¨ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
            const finalDoorMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            finalDoor = new THREE.Mesh(doorGeometry, finalDoorMaterial);
            finalDoor.position.set(0, 2.5, -40);
            finalDoor.castShadow = true;
            finalDoor.receiveShadow = true;
            finalDoor.userData.isDoor = true;
            finalDoor.userData.isFinalDoor = true;
            scene.add(finalDoor);
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©
        function addClues() {
            // ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø£Ø¯Ù„Ø© Ù…Ø¹ Ù†ØµÙˆØµ ÙˆØµÙÙŠØ©
            const clueData = [
                { position: { x: 15, y: 1, z: 10 }, title: "Ø¯Ù„ÙŠÙ„ #1", description: "Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ†Ø² Ø¨Ø§Ù„Ù‚Ø±Ø¨ Ù…Ù† Ø§Ù„Ù…Ø§Ø¡" },
                { position: { x: -20, y: 1, z: -15 }, title: "Ø¯Ù„ÙŠÙ„ #2", description: "Ø§Ù„ÙƒÙ†Ø² Ù…Ø®Ø¨Ø£ Ø¨ÙŠÙ† Ø§Ù„Ø£Ø´Ø¬Ø§Ø± Ø§Ù„Ø¹Ø§Ù„ÙŠØ©" },
                { position: { x: 5, y: 1, z: -25 }, title: "Ø¯Ù„ÙŠÙ„ #3", description: "Ø§Ù†Ø¸Ø± ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø´Ù…Ø§Ù„ÙŠ Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø²" },
                { position: { x: -10, y: 1, z: 20 }, title: "Ø¯Ù„ÙŠÙ„ #4", description: "Ø§Ù„ÙƒÙ†Ø² Ù…Ø­Ø§Ø· Ø¨Ø£Ø±Ø¨Ø¹Ø© Ø£Ø´Ø¬Ø§Ø±" },
                { position: { x: 25, y: 1, z: -5 }, title: "Ø¯Ù„ÙŠÙ„ #5", description: "Ø§Ù„ÙƒÙ†Ø² ÙŠØªÙˆÙ‡Ø¬ Ø¨Ù„ÙˆÙ† Ø°Ù‡Ø¨ÙŠ" }
            ];
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø¯Ù„Ø© ÙƒÙƒØ±Ø§Øª Ù…ØªÙˆÙ‡Ø¬Ø©
            const clueGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            
            for (let i = 0; i < clueData.length; i++) {
                const data = clueData[i];
                const clueMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5
                });
                
                const clue = new THREE.Mesh(clueGeometry, clueMaterial);
                clue.position.set(data.position.x, data.position.y, data.position.z);
                
                // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¯Ù„ÙŠÙ„
                clue.userData = {
                    isClue: true,
                    title: data.title,
                    description: data.description
                };
                
                scene.add(clue);
                clues.push(clue);
            }
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒÙ†Ø² Ø§Ù„Ù…Ø®ÙÙŠ
        function addHiddenTreasure() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒÙ†Ø² ÙƒØµÙ†Ø¯ÙˆÙ‚ Ø°Ù‡Ø¨ÙŠ Ù…ØªÙˆÙ‡Ø¬
            const treasureGeometry = new THREE.BoxGeometry(1, 1, 1);
            const treasureMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.7,
                metalness: 1.0,
                roughness: 0.3
            });
            
            hiddenTreasure = new THREE.Mesh(treasureGeometry, treasureMaterial);
            
            // ÙˆØ¶Ø¹ Ø§Ù„ÙƒÙ†Ø² ÙÙŠ Ù…ÙƒØ§Ù† Ù…Ø®ÙÙŠ Ø¨Ø¹ÙŠØ¯Ø§Ù‹ Ø¹Ù† Ø§Ù„Ø£Ø¯Ù„Ø©
            hiddenTreasure.position.set(-30, 1, -30);
            
            // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙƒÙ†Ø²
            hiddenTreasure.userData = {
                isTreasure: true
            };
            
            scene.add(hiddenTreasure);
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø¬Ù…Ø¹
        function addCollectibleItems() {
            const itemGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const itemMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            
            for (let i = 0; i < totalItems; i++) {
                const item = new THREE.Mesh(itemGeometry, itemMaterial);
                item.position.x = (Math.random() - 0.5) * 80;
                item.position.z = (Math.random() - 0.5) * 80;
                item.position.y = 0.5;
                item.castShadow = true;
                item.userData.isCollectible = true;
                scene.add(item);
                items.push(item);
            }
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´Ø®ØµÙŠØ©
        function createCharacter() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
            character = new THREE.Group();
            character.position.y = 0;
            scene.add(character);
            
            // Ø¬Ø³Ù… Ø§Ù„Ø´Ø®ØµÙŠØ©
            const bodyGeometry = new THREE.BoxGeometry(1, 2, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            character.add(body);
            
            // Ø±Ø£Ø³ Ø§Ù„Ø´Ø®ØµÙŠØ©
            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.5; // ÙÙˆÙ‚ Ø§Ù„Ø¬Ø³Ù…
            character.add(head);
            
            // Ø¹ÙŠÙˆÙ† Ø§Ù„Ø´Ø®ØµÙŠØ©
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.2, 2.6, 0.4);
            character.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.2, 2.6, 0.4);
            character.add(rightEye);
            
            // Ù…Ø¤Ø´Ø± Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ù…Ø®Ø±ÙˆØ· ÙÙŠ Ù…Ù‚Ø¯Ù…Ø© Ø§Ù„Ø´Ø®ØµÙŠØ©)
            const directionGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const directionMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); // Ù„ÙˆÙ† Ù…Ø®ØªÙ„Ù Ø¹Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
            const directionIndicator = new THREE.Mesh(directionGeometry, directionMaterial);
            directionIndicator.rotation.x = Math.PI / 2; // ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø®Ø±ÙˆØ· Ù„Ù„Ø£Ù…Ø§Ù…
            directionIndicator.position.set(0, 1, -0.8); // ÙˆØ¶Ø¹Ù‡ ÙÙŠ Ù…Ù‚Ø¯Ù…Ø© Ø§Ù„Ø´Ø®ØµÙŠØ©
            character.add(directionIndicator);
            
            // Ø¥Ø¶Ø§ÙØ© Ø£Ø·Ø±Ø§Ù Ù„Ù„Ø´Ø®ØµÙŠØ©
            const limbGeometry = new THREE.BoxGeometry(0.25, 1, 0.25);
            const limbMaterial = new THREE.MeshStandardMaterial({ color: 0xff7700 });
            
            // Ø§Ù„Ø°Ø±Ø§Ø¹Ø§Ù†
            const rightArm = new THREE.Mesh(limbGeometry, limbMaterial);
            rightArm.position.set(0.7, 1.5, 0);
            character.add(rightArm);
            
            const leftArm = new THREE.Mesh(limbGeometry, limbMaterial);
            leftArm.position.set(-0.7, 1.5, 0);
            character.add(leftArm);
            
            // Ø§Ù„Ø³Ø§Ù‚Ø§Ù†
            const rightLeg = new THREE.Mesh(limbGeometry, limbMaterial);
            rightLeg.position.set(0.3, 0.5, 0);
            character.add(rightLeg);
            
            const leftLeg = new THREE.Mesh(limbGeometry, limbMaterial);
            leftLeg.position.set(-0.3, 0.5, 0);
            character.add(leftLeg);
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø®ØµÙŠØ© Ù„Ù„Ø§Ø¹Ø¨ Ø¢Ø®Ø±
        function createOtherCharacter(playerName) {
            const otherCharacter = new THREE.Group();
            otherCharacter.position.y = 0;
            
            // Ø§Ù„Ø¬Ø³Ù…
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1, 2, 1),
                new THREE.MeshStandardMaterial({ color: 0x0088ff })
            );
            body.position.y = 1;
            otherCharacter.add(body);
            
            // Ø§Ù„Ø±Ø£Ø³
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0xccccff })
            );
            head.position.y = 2.25;
            otherCharacter.add(head);
            
            // Ø§Ù„Ø¹ÙŠÙ†ÙŠÙ†
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.2, 2.35, 0.4);
            otherCharacter.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.2, 2.35, 0.4);
            otherCharacter.add(rightEye);
            
            // Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†
            const armGeometry = new THREE.BoxGeometry(0.25, 1.5, 0.25);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0x0088ff });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(0.75, 1, 0);
            otherCharacter.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(-0.75, 1, 0);
            otherCharacter.add(rightArm);
            
            // Ø§Ù„Ø³Ø§Ù‚ÙŠÙ†
            const legGeometry = new THREE.BoxGeometry(0.25, 1.5, 0.25);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(0.25, -0.25, 0);
            otherCharacter.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(-0.25, -0.25, 0);
            otherCharacter.add(rightLeg);
            
            // Ù…Ø®Ø±ÙˆØ· Ù„Ù„Ø¥Ø´Ø§Ø±Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
            const directionCone = new THREE.Mesh(
                new THREE.ConeGeometry(0.25, 1, 8),
                new THREE.MeshStandardMaterial({ color: 0xffff00 })
            );
            directionCone.position.set(0, 1, -0.75);
            directionCone.rotation.x = -Math.PI / 2;
            otherCharacter.add(directionCone);
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙˆÙ‚ Ø§Ù„Ø´Ø®ØµÙŠØ©
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = '#ffffff';
            context.font = 'bold 24px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(playerName, 128, 32);
            
            const nameTexture = new THREE.CanvasTexture(canvas);
            const nameMaterial = new THREE.SpriteMaterial({ map: nameTexture, transparent: true });
            const nameSprite = new THREE.Sprite(nameMaterial);
            nameSprite.position.set(0, 3, 0);
            nameSprite.scale.set(2, 0.5, 1);
            otherCharacter.add(nameSprite);
            
            return otherCharacter;
        }
        
        // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        function startGame() {
            startScreen.style.display = 'none';

            // Connect to socket server and join room
            socket = io();
            socket.on('connect', () => {
                console.log('Connected to server with ID:', socket.id);
                socket.emit('join-room', { roomId, playerName });
            });

            // Listen for game state updates from the server
            socket.on('state', (players) => {
                // Remove players who have disconnected
                Object.keys(otherPlayers).forEach(id => {
                    if (!players[id]) {
                        scene.remove(otherPlayers[id]);
                        delete otherPlayers[id];
                        delete playerTargets[id];
                    }
                });

                for (const id in players) {
                    if (id === socket.id) continue; // Skip our own player

                    const playerData = players[id];
                    if (!otherPlayers[id]) {
                        // Add a new player to the scene with direction indicator
                        console.log(`Adding new player ${playerData.name} (${id})`);
                        
                        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨
                        const playerGroup = new THREE.Group();
                        
                        // Ø¬Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨
                        const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
                        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
                        const playerBody = new THREE.Mesh(playerGeometry, playerMaterial);
                        playerBody.castShadow = true;
                        playerBody.position.y = 1; // Ø±ÙØ¹ Ø§Ù„Ø¬Ø³Ù… Ù‚Ù„ÙŠÙ„Ø§Ù‹
                        playerGroup.add(playerBody);
                        
                        // Ù…Ø¤Ø´Ø± Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ù…Ø®Ø±ÙˆØ· ÙÙŠ Ù…Ù‚Ø¯Ù…Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨)
                        const directionGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
                        const directionMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                        const directionIndicator = new THREE.Mesh(directionGeometry, directionMaterial);
                        directionIndicator.rotation.x = Math.PI / 2; // ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø®Ø±ÙˆØ· Ù„Ù„Ø£Ù…Ø§Ù…
                        directionIndicator.position.set(0, 1, -0.8); // ÙˆØ¶Ø¹Ù‡ ÙÙŠ Ù…Ù‚Ø¯Ù…Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨
                        playerGroup.add(directionIndicator);
                        
                        // Ø¥Ø¶Ø§ÙØ© Ø£Ø·Ø±Ø§Ù Ù„Ù„Ø´Ø®ØµÙŠØ©
                        const limbGeometry = new THREE.BoxGeometry(0.25, 1, 0.25);
                        const limbMaterial = new THREE.MeshStandardMaterial({ color: 0x3366ff });
                        
                        // Ø§Ù„Ø°Ø±Ø§Ø¹Ø§Ù†
                        const rightArm = new THREE.Mesh(limbGeometry, limbMaterial);
                        rightArm.position.set(0.7, 1.5, 0);
                        playerGroup.add(rightArm);
                        
                        const leftArm = new THREE.Mesh(limbGeometry, limbMaterial);
                        leftArm.position.set(-0.7, 1.5, 0);
                        playerGroup.add(leftArm);
                        
                        // Ø§Ù„Ø³Ø§Ù‚Ø§Ù†
                        const rightLeg = new THREE.Mesh(limbGeometry, limbMaterial);
                        rightLeg.position.set(0.3, 0.5, 0);
                        playerGroup.add(rightLeg);
                        
                        const leftLeg = new THREE.Mesh(limbGeometry, limbMaterial);
                        leftLeg.position.set(-0.3, 0.5, 0);
                        playerGroup.add(leftLeg);
                        
                        // Ø¥Ø¶Ø§ÙØ© Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙˆÙ‚ Ø§Ù„Ø´Ø®ØµÙŠØ©
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 256;
                        canvas.height = 64;
                        context.font = '24px Arial';
                        context.fillStyle = 'white';
                        context.textAlign = 'center';
                        context.fillText(playerData.name, 128, 40);
                        
                        const nameTexture = new THREE.CanvasTexture(canvas);
                        const nameMaterial = new THREE.SpriteMaterial({ map: nameTexture, transparent: true });
                        const nameSprite = new THREE.Sprite(nameMaterial);
                        nameSprite.position.set(0, 3, 0);
                        nameSprite.scale.set(3, 0.8, 1);
                        playerGroup.add(nameSprite);
                        
                        otherPlayers[id] = playerGroup;
                        scene.add(playerGroup);
                        
                        // ØªÙ‡ÙŠØ¦Ø© Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙŠ
                        playerTargets[id] = {
                            position: new THREE.Vector3(playerData.x, playerData.y, playerData.z),
                            rotation: { y: playerData.rotation ? playerData.rotation.y : 0 }
                        };
                        
                        // ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙŠ Ù…ÙˆÙ‚Ø¹Ù‡ Ø§Ù„Ø£ÙˆÙ„ÙŠ
                        otherPlayers[id].position.copy(playerTargets[id].position);
                        otherPlayers[id].rotation.y = playerTargets[id].rotation.y;
                    } 
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙˆØ§Ù„Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù Ù„Ù„Ø§Ø¹Ø¨
                    if (!playerTargets[id]) {
                        playerTargets[id] = {
                            position: new THREE.Vector3(),
                            rotation: { y: 0 }
                        };
                    }
                    
                    // ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
                    playerTargets[id].position.set(playerData.x, playerData.y, playerData.z);
                    
                    // ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆÙØ±Ø§Ù‹
                    if (playerData.rotation && typeof playerData.rotation.y === 'number') {
                        playerTargets[id].rotation.y = playerData.rotation.y;
                    }
                    
                    // Ù„Ø§ Ù†Ù‚ÙˆÙ… Ø¨ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù‡Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©ØŒ Ø¨Ù„ Ø³Ù†Ù‚ÙˆÙ… Ø¨Ø°Ù„Ùƒ ÙÙŠ Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø³Ù„Ø³
                }
            });

            animate();
        }
        
        // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
        function setupTouchControls() {
            upBtn.addEventListener('touchstart', () => { touchControls.up = true; }, { passive: true });
            upBtn.addEventListener('touchend', () => { touchControls.up = false; }, { passive: true });
            
            leftBtn.addEventListener('touchstart', () => { touchControls.left = true; }, { passive: true });
            leftBtn.addEventListener('touchend', () => { touchControls.left = false; }, { passive: true });
            
            rightBtn.addEventListener('touchstart', () => { touchControls.right = true; }, { passive: true });
            rightBtn.addEventListener('touchend', () => { touchControls.right = false; }, { passive: true });
            
            downBtn.addEventListener('touchstart', () => { touchControls.down = true; }, { passive: true });
            downBtn.addEventListener('touchend', () => { touchControls.down = false; }, { passive: true });
        }
        
        // Ø£Ø­Ø¯Ø§Ø« Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        function onKeyDown(event) {
            keys[event.code] = true;
        }
        
        function onKeyUp(event) {
            keys[event.code] = false;
        }
        
        // ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø©
        function showMessage(title, content) {
            messageTitle.textContent = title;
            messageContent.textContent = content;
            messageBox.style.display = 'block';
        }
        
        // Ø¹Ø±Ø¶ Ù„ØºØ²
        function showPuzzle() {
            activePuzzle = puzzles[Math.floor(Math.random() * puzzles.length)];
            puzzleTitle.textContent = activePuzzle.title;
            puzzleQuestion.textContent = activePuzzle.question;
            
            puzzleOptions.innerHTML = '';
            activePuzzle.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'puzzle-option';
                button.textContent = option;
                button.addEventListener('click', () => checkPuzzleAnswer(index));
                puzzleOptions.appendChild(button);
            });
            
            puzzleScreen.style.display = 'flex';
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù„ØºØ²
        function checkPuzzleAnswer(selectedIndex) {
            if (selectedIndex === activePuzzle.correct) {
                score += 20;
                scoreInfo.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
                showMessage("Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©!", "Ù„Ù‚Ø¯ Ø­ØµÙ„Øª Ø¹Ù„Ù‰ 20 Ù†Ù‚Ø·Ø©!");
            } else {
                showMessage("Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©", `Ø§Ù„Ø¬ÙˆØ§Ø¨ Ø§Ù„ØµØ­ÙŠØ­ Ù‡Ùˆ: ${activePuzzle.options[activePuzzle.correct]}`);
            }
            puzzleScreen.style.display = 'none';
            activePuzzle = null;
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…Ø§Øª
        function checkCollisions() {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø¬Ù…Ø¹
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (character.position.distanceTo(item.position) < 1.5) {
                    scene.remove(item);
                    items.splice(i, 1);
                    collectedItems++;
                    score += 10;
                    itemsInfo.textContent = `Ø§Ù„Ø¹Ù†Ø§ØµØ±: ${collectedItems}/${totalItems}`;
                    scoreInfo.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
                    
                    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù†ØµØ± Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
                    const inventoryItem = document.createElement('div');
                    inventoryItem.className = 'inventory-item';
                    inventoryItem.textContent = 'ğŸ”‘';
                    inventory.appendChild(inventoryItem);
                    inventoryItems.push('key');
                    
                    showMessage("Ù„Ù‚Ø¯ ÙˆØ¬Ø¯Øª Ù…ÙØªØ§Ø­Ø§Ù‹!", `Ù„Ø¯ÙŠÙƒ Ø§Ù„Ø¢Ù† ${collectedItems} Ù…Ù† ${totalItems} Ù…ÙØ§ØªÙŠØ­`);
                    
                    if (collectedItems === totalItems) {
                        showMessage("ØªÙ‡Ø§Ù†ÙŠÙ†Ø§!", "Ù„Ù‚Ø¯ Ø¬Ù…Ø¹Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙØ§ØªÙŠØ­! Ø§Ù„Ø¢Ù† Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ Ø§Ù„Ø¨Ø§Ø¨ Ø§Ù„Ø°Ù‡Ø¨ÙŠ Ù„Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©!");
                        missionText.textContent = "Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ Ø§Ù„Ø¨Ø§Ø¨ Ø§Ù„Ø°Ù‡Ø¨ÙŠ Ù„Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©";
                    }
                }
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ø¨ÙˆØ§Ø¨
            doors.forEach(door => {
                if (character.position.distanceTo(door.position) < 3) {
                    if (door.userData.isFinalDoor) {
                        if (collectedItems >= totalItems) {
                            showMessage("ØªÙ‡Ø§Ù†ÙŠÙ†Ø§!", "Ù„Ù‚Ø¯ Ø£ÙƒÙ…Ù„Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­!");
                            // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø¹Ù†Ø¯ Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
                        } else {
                            showMessage("Ø§Ù„Ø¨Ø§Ø¨ Ù…ØºÙ„Ù‚", "Ø£Ù†Øª Ø¨Ø­Ø§Ø¬Ø© Ø¥Ù„Ù‰ Ø¬Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø£ÙˆÙ„Ø§Ù‹!");
                        }
                    } else if (door.userData.requiresKey) {
                        if (inventoryItems.includes('key')) {
                            // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙØªØ§Ø­ Ù„ÙØªØ­ Ø§Ù„Ø¨Ø§Ø¨
                            const keyIndex = inventoryItems.indexOf('key');
                            inventoryItems.splice(keyIndex, 1);
                            inventory.removeChild(inventory.children[keyIndex]);
                            
                            scene.remove(door);
                            doors = doors.filter(d => d !== door);
                            showMessage("Ù„Ù‚Ø¯ ÙØªØ­Øª Ø§Ù„Ø¨Ø§Ø¨!", "Ø§Ø³ØªØ®Ø¯Ù…Øª Ù…ÙØªØ§Ø­Ø§Ù‹ Ù„ÙØªØ­ Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø§Ø¨");
                        } else {
                            showMessage("Ø§Ù„Ø¨Ø§Ø¨ Ù…ØºÙ„Ù‚", "Ø£Ù†Øª Ø¨Ø­Ø§Ø¬Ø© Ø¥Ù„Ù‰ Ù…ÙØªØ§Ø­ Ù„ÙØªØ­ Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø§Ø¨!");
                        }
                    } else {
                        // Ø¨Ø§Ø¨ Ø¨Ø¯ÙˆÙ† Ù…ÙØªØ§Ø­ - Ø¹Ø±Ø¶ Ù„ØºØ²
                        showPuzzle();
                    }
                }
            });
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ©
        function updateMovement() {
            // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
            if (touchControls.up) moveCharacter(0, 0, -speed);
            if (touchControls.down) moveCharacter(0, 0, speed);
            if (touchControls.left) character.rotation.y += rotationSpeed;
            if (touchControls.right) character.rotation.y -= rotationSpeed;
            
            // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            if (keys['ArrowUp'] || keys['KeyW']) moveCharacter(0, 0, -speed);
            if (keys['ArrowDown'] || keys['KeyS']) moveCharacter(0, 0, speed);
            if (keys['ArrowLeft'] || keys['KeyA']) character.rotation.y += rotationSpeed;
            if (keys['ArrowRight'] || keys['KeyD']) character.rotation.y -= rotationSpeed;
            
            // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù„ØªØ¨Ø¹ Ø§Ù„Ø´Ø®ØµÙŠØ©
            const cameraOffset = new THREE.Vector3(0, 5, 10);
            cameraOffset.applyQuaternion(character.quaternion);
            camera.position.copy(character.position).add(cameraOffset);
            camera.lookAt(character.position);
            
            // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹
            positionInfo.textContent = `Ø§Ù„Ù…ÙˆÙ‚Ø¹: (${character.position.x.toFixed(1)}, ${character.position.y.toFixed(1)}, ${character.position.z.toFixed(1)})`;
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…Ø§Øª
            checkCollisions();
            
            // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ† Ø¨Ø´ÙƒÙ„ Ø³Ù„Ø³
            updateOtherPlayers();

            // Send position and rotation to server if connected and moving
            if (socket && socket.connected) {
                const moved = keys['ArrowUp'] || keys['KeyW'] || keys['ArrowDown'] || keys['KeyS'] || touchControls.up || touchControls.down;
                const rotated = keys['ArrowLeft'] || keys['KeyA'] || keys['ArrowRight'] || keys['KeyD'] || touchControls.left || touchControls.right;

                if (moved || rotated) {
                    socket.emit('move', {
                        roomId,
                        position: {
                            x: character.position.x,
                            y: character.position.y,
                            z: character.position.z
                        },
                        rotation: {
                            y: character.rotation.y
                        }
                    });
                }
            }
        }
        
        // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ† Ø¨Ø´ÙƒÙ„ Ø³Ù„Ø³
        function updateOtherPlayers() {
            for (const id in otherPlayers) {
                if (playerTargets[id]) {
                    // ØªØ­Ø±ÙŠÙƒ Ø³Ù„Ø³ Ù„Ù„Ù…ÙˆÙ‚Ø¹
                    otherPlayers[id].position.lerp(playerTargets[id].position, interpolationFactor);
                    
                    // ØªØ­Ø±ÙŠÙƒ Ø³Ù„Ø³ Ù„Ù„Ø¯ÙˆØ±Ø§Ù†
                    // Ù†Ø­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø®Ø§ØµØ© Ù„Ù„Ø¯ÙˆØ±Ø§Ù† Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ø·ÙˆÙŠÙ„
                    const currentRotation = otherPlayers[id].rotation.y;
                    const targetRotation = playerTargets[id].rotation.y;
                    
                    // Ø­Ø³Ø§Ø¨ Ø£Ù‚ØµØ± Ù…Ø³Ø§Ø± Ù„Ù„Ø¯ÙˆØ±Ø§Ù†
                    let rotationDiff = targetRotation - currentRotation;
                    
                    // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ù„ÙŠÙƒÙˆÙ† ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚ [-PI, PI]
                    if (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
                    if (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;
                    
                    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø¨Ø´ÙƒÙ„ Ø³Ù„Ø³
                    otherPlayers[id].rotation.y += rotationDiff * interpolationFactor;
                }
            }
        }
        
        // Ø­Ø±ÙƒØ© Ø§Ù„Ø´Ø®ØµÙŠØ©
        function moveCharacter(x, y, z) {
            const direction = new THREE.Vector3(x, y, z);
            direction.applyQuaternion(character.quaternion);
            character.position.add(direction);
            
            // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¨Ù‚Ø§Ø¡ Ø§Ù„Ø´Ø®ØµÙŠØ© ÙÙˆÙ‚ Ø§Ù„Ø£Ø±Ø¶ÙŠØ©
            character.position.y = 1;
        }
        
        // Ø¯ÙˆØ±Ø© Ø§Ù„ØªØµÙŠÙŠØ±
        function animate() {
            requestAnimationFrame(animate);
            updateMovement();
            renderer.render(scene, camera);
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ Ø§Ù„Ø­Ø¯Ø« Ù„Ø²Ø± Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        document.getElementById('start-button').addEventListener('click', function() {
            startGame();
        });
        
        // Ø¯Ø§Ù„Ø© Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        function startGame() {
            // Ø¥Ø®ÙØ§Ø¡ Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
            document.getElementById('start-screen').style.display = 'none';
            
            // Ø¥Ø¸Ù‡Ø§Ø± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
            document.getElementById('ui').style.display = 'block';
            
            // ØªØ¹ÙŠÙŠÙ† Ø­Ø§Ù„Ø© Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
            gameStarted = true;
            
            // ØªØ­Ø¯ÙŠØ« Ù†Øµ Ø§Ù„Ù…Ù‡Ù…Ø©
            document.getElementById('mission-text').textContent = 'Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£Ø¯Ù„Ø© Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø² Ø§Ù„Ù…Ø®ÙÙŠ!';
            
            // Ø¥Ø¸Ù‡Ø§Ø± Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ÙŠØ©
            showMessage('Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ!', 'Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ù…Ø®ÙÙŠØ© ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù… Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø² Ø§Ù„Ù…Ø®ÙÙŠ. Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø°ÙŠ ÙŠØ¬Ø¯Ù‡ Ø£ÙˆÙ„Ø§Ù‹ ÙŠÙÙˆØ²!');
        }
        
        // Ø¥Ø¸Ù‡Ø§Ø± Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø§Ø¹Ø¨
        function showMessage(title, content) {
            const messageBox = document.getElementById('message-box');
            const messageTitle = document.getElementById('message-title');
            const messageContent = document.getElementById('message-content');
            
            messageTitle.textContent = title;
            messageContent.textContent = content;
            messageBox.style.display = 'block';
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ Ø§Ù„Ø­Ø¯Ø« Ù„Ø²Ø± Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
        document.getElementById('close-message').addEventListener('click', function() {
            document.getElementById('message-box').style.display = 'none';
        });
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…Ø§Øª Ù…Ø¹ Ø§Ù„Ø£Ø¯Ù„Ø© ÙˆØ§Ù„ÙƒÙ†Ø²
        function checkCollisions() {
            if (!gameStarted || treasureFound) return;
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ù…Ø¹ Ø§Ù„Ø£Ø¯Ù„Ø©
            for (let i = 0; i < clues.length; i++) {
                const clue = clues[i];
                if (!discoveredClues.includes(i) && character.position.distanceTo(clue.position) < 2) {
                    // Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¯Ù„ÙŠÙ„ Ø¬Ø¯ÙŠØ¯
                    discoveredClues.push(i);
                    
                    // Ø¥Ø¸Ù‡Ø§Ø± Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø§Ø¹Ø¨
                    showMessage(clue.userData.title, clue.userData.description);
                    
                    // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¯Ù„ÙŠÙ„
                    document.getElementById('clue-info').textContent = `Ø§Ù„Ø¯Ù„ÙŠÙ„: ${clue.userData.description}`;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙƒØªØ´ÙØ©
                    collectedItems++;
                    document.getElementById('items-info').textContent = `Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙƒØªØ´ÙØ©: ${collectedItems}`;
                    
                    // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
                    if (socket && socket.connected) {
                        socket.emit('clue-found', { roomId, clueIndex: i });
                    }
                    
                    // ØªØºÙŠÙŠØ± Ù„ÙˆÙ† Ø§Ù„Ø¯Ù„ÙŠÙ„ Ù„ÙŠØ¸Ù‡Ø± Ø£Ù†Ù‡ ØªÙ… Ø§ÙƒØªØ´Ø§ÙÙ‡
                    clue.material.color.set(0xFFFFFF);
                    clue.material.emissive.set(0xFFFFFF);
                }
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ù…Ø¹ Ø§Ù„ÙƒÙ†Ø²
            if (hiddenTreasure && character.position.distanceTo(hiddenTreasure.position) < 2) {
                // Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø²
                treasureFound = true;
                winner = playerName;
                
                // Ø¥Ø¸Ù‡Ø§Ø± Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø§Ø¹Ø¨
                showMessage("ØªÙ‡Ø§Ù†ÙŠÙ†Ø§!", "Ù„Ù‚Ø¯ Ø¹Ø«Ø±Øª Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ†Ø² Ø§Ù„Ù…Ø®ÙÙŠ!");
                
                // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
                if (socket && socket.connected) {
                    socket.emit('treasure-found', { roomId, playerName });
                }
                
                // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ÙƒÙ†Ø²
                hiddenTreasure.visible = false;
            }
        }
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
        init();
    </script>
</body>
</html>